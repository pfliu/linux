/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
/* THIS FILE IS AUTOGENERATED BY BPFTOOL! */
#ifndef __KEXEC_PE_PARSER_BPF_SKEL_H__
#define __KEXEC_PE_PARSER_BPF_SKEL_H__

#include <bpf/skel_internal.h>
static char *opts_data, *opts_insn;
static unsigned int opts_data_sz, opts_insn_sz;

struct kexec_pe_parser_bpf {
	struct bpf_loader_ctx ctx;
	struct {
		struct bpf_map_desc ringbuf_1;
		struct bpf_map_desc ringbuf_2;
		struct bpf_map_desc ringbuf_3;
		struct bpf_map_desc ringbuf_4;
		struct bpf_map_desc rodata;
		struct bpf_map_desc data;
		struct bpf_map_desc bss;
		struct bpf_map_desc rodata_str1_1;
	} maps;
	struct {
		struct bpf_prog_desc parse_pe;
		struct bpf_prog_desc post_parse_pe;
	} progs;
	struct {
		int parse_pe_fd;
		int post_parse_pe_fd;
	} links;
};

static inline int
kexec_pe_parser_bpf__parse_pe__attach(struct kexec_pe_parser_bpf *skel)
{
	int prog_fd = skel->progs.parse_pe.prog_fd;
	int fd = skel_raw_tracepoint_open(NULL, prog_fd);

	if (fd > 0)
		skel->links.parse_pe_fd = fd;
	return fd;
}

static inline int
kexec_pe_parser_bpf__post_parse_pe__attach(struct kexec_pe_parser_bpf *skel)
{
	int prog_fd = skel->progs.post_parse_pe.prog_fd;
	int fd = skel_raw_tracepoint_open(NULL, prog_fd);

	if (fd > 0)
		skel->links.post_parse_pe_fd = fd;
	return fd;
}

static inline int
kexec_pe_parser_bpf__attach(struct kexec_pe_parser_bpf *skel)
{
	int ret = 0;

	ret = ret < 0 ? ret : kexec_pe_parser_bpf__parse_pe__attach(skel);
	ret = ret < 0 ? ret : kexec_pe_parser_bpf__post_parse_pe__attach(skel);
	return ret < 0 ? ret : 0;
}

static inline void
kexec_pe_parser_bpf__detach(struct kexec_pe_parser_bpf *skel)
{
	skel_closenz(skel->links.parse_pe_fd);
	skel_closenz(skel->links.post_parse_pe_fd);
}
static void
kexec_pe_parser_bpf__destroy(struct kexec_pe_parser_bpf *skel)
{
	if (!skel)
		return;
	kexec_pe_parser_bpf__detach(skel);
	skel_closenz(skel->progs.parse_pe.prog_fd);
	skel_closenz(skel->progs.post_parse_pe.prog_fd);
	skel_closenz(skel->maps.ringbuf_1.map_fd);
	skel_closenz(skel->maps.ringbuf_2.map_fd);
	skel_closenz(skel->maps.ringbuf_3.map_fd);
	skel_closenz(skel->maps.ringbuf_4.map_fd);
	skel_closenz(skel->maps.rodata.map_fd);
	skel_closenz(skel->maps.data.map_fd);
	skel_closenz(skel->maps.bss.map_fd);
	skel_closenz(skel->maps.rodata_str1_1.map_fd);
	skel_free(skel);
}
static inline struct kexec_pe_parser_bpf *
kexec_pe_parser_bpf__open(void)
{
	struct kexec_pe_parser_bpf *skel;

	skel = skel_alloc(sizeof(*skel));
	if (!skel)
		goto cleanup;
	skel->ctx.sz = (void *)&skel->links - (void *)skel;
	return skel;
cleanup:
	kexec_pe_parser_bpf__destroy(skel);
	return NULL;
}

static inline int
kexec_pe_parser_bpf__load(struct kexec_pe_parser_bpf *skel)
{
	struct bpf_load_and_run_opts opts = {};
	int err;

	opts.ctx = (struct bpf_loader_ctx *)skel;
	opts.data_sz = opts_data_sz;
	opts.data = (void *)opts_data;
	opts.insns_sz = opts_insn_sz;
	opts.insns = (void *)opts_insn;

	err = bpf_load_and_run(&opts);
	if (err < 0)
		return err;
	return 0;
}

static inline struct kexec_pe_parser_bpf *
kexec_pe_parser_bpf__open_and_load(void)
{
	struct kexec_pe_parser_bpf *skel;

	skel = kexec_pe_parser_bpf__open();
	if (!skel)
		return NULL;
	if (kexec_pe_parser_bpf__load(skel)) {
		kexec_pe_parser_bpf__destroy(skel);
		return NULL;
	}
	return skel;
}

__attribute__((unused)) static void
kexec_pe_parser_bpf__assert(struct kexec_pe_parser_bpf *s __attribute__((unused)))
{
#ifdef __cplusplus
#define _Static_assert static_assert
#endif
#ifdef __cplusplus
#undef _Static_assert
#endif
}

#endif /* __KEXEC_PE_PARSER_BPF_SKEL_H__ */
